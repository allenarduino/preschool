{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Comment\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});","map":{"version":3,"sources":["/media/allen/SIMBAD/Flaskprojects/Preschool/design/preschool/Student_Frontend/wap/node_modules/@babel/types/lib/definitions/core.js"],"names":["Object","defineProperty","exports","value","patternLikeCommon","functionDeclarationCommon","functionTypeAnnotationCommon","functionCommon","_is","_interopRequireDefault","require","_isValidIdentifier","_helperValidatorIdentifier","_constants","_utils","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","fields","elements","validate","chain","assertValueType","assertEach","assertNodeOrValueType","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","val","validator","left","assertNodeType","right","builder","BINARY_OPERATORS","expression","inOp","oneOfNodeTypes","directives","body","label","optional","assign","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","tokens","type","init","update","params","generator","async","returnType","declare","id","parent","inherits","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Comment\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});"]},"metadata":{},"sourceType":"script"}